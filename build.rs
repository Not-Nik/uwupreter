use std::{
    io::Write,
    path::{Path, PathBuf},
    env,
    fs
};

fn main() {
    gen_lalrpop();
    gen_test_cases();
}

fn gen_lalrpop() {
    lalrpop::Configuration::new()
        .emit_rerun_directives(true)
        .process_current_dir()
        .expect("failed to run LALRPOP");
}

fn gen_test_cases() {
    gen_test_cases_for_suite(
        "parser",
        &[
            ("ok", "ok"),
            ("ok", "interpreter_err"),
            ("ok", "analysis_err"),
            ("err", "parser_err"),
        ],
    );
    println!("cargo::rerun-if-changed=tests/inputs");
}

fn gen_test_cases_for_suite(suite: &str, cases: &[(&str, &str)]) {
    let tests_path = Path::new("tests");

    // Don't generate test cases if the test suite doesn't exist.
    if !tests_path.join(format!("{suite}.rs")).try_exists().unwrap() {
        return;
    }

    let out_dir = env::var_os("OUT_DIR").expect("`OUT_DIR` was not set");
    let mut output_path = PathBuf::from(out_dir);
    output_path.push(format!("cases_{suite}.rs"));

    // Create test case folder and file.
    let mut output_file = fs::File::create(output_path).expect("failed to create output file");
    output_file
        .write_all(b"// This file is @generated by `build.rs`, do not edit manually.\n")
        .unwrap();

    for (outcome, inputs) in cases {
        write!(output_file, "\nmod {inputs} {{").unwrap();

        let mut inputs_path = tests_path.join("inputs");
        inputs_path.push(inputs);

        // The order of the entries is not guaranteed, so we sort them here
        // to keep the order stable.
        let mut entries = fs::read_dir(inputs_path)
            .unwrap()
            .map(|entry| entry.unwrap().path())
            .collect::<Vec<_>>();
        entries.sort_unstable();

        // Write test cases to output file.
        for entry in entries {
            // Don't generate cases for the output files.
            if !entry.extension().is_some_and(|ext| ext == "c1") {
                continue;
            }

            let test_name = entry
                .file_stem()
                .unwrap()
                .to_str()
                .expect("non UTF-8 file name");
            let escaped_path = entry
                .to_str()
                .expect("non UTF-8 file path")
                .escape_default()
                .collect::<String>();

            writeln!(
                output_file,
                "
    #[test]
    fn {test_name}() {{
        crate::run_test_{outcome}(\"{escaped_path}\");
    }}"
            )
            .unwrap();
        }

        output_file.write_all(b"}\n").unwrap();
    }
}
