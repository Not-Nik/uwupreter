//! The C1 parser, implemented with the parser generator LALRPOP.

use crate::{ast, lexer::{LexicalError}, token::Token};

grammar;

extern {
    type Location = usize;
    type Error = LexicalError;

    enum Token {
        "bool" => Token::KwBool,
        "do" => Token::KwDo,
        "else" => Token::KwElse,
        "float" => Token::KwFloat,
        "for" => Token::KwFor,
        "if" => Token::KwIf,
        "int" => Token::KwInt,
        "print" => Token::KwPrint,
        "return" => Token::KwReturn,
        "void" => Token::KwVoid,
        "while" => Token::KwWhile,
        "+" => Token::Add,
        "-" => Token::Sub,
        "*" => Token::Mul,
        "/" => Token::Div,
        "=" => Token::Assign,
        "==" => Token::Eq,
        "!=" => Token::Neq,
        "<" => Token::Lt,
        ">" => Token::Gt,
        "<=" => Token::Leq,
        ">=" => Token::Geq,
        "&&" => Token::LogAnd,
        "||" => Token::LogOr,
        "," => Token::Comma,
        ";" => Token::Semicolon,
        "(" => Token::LParen,
        ")" => Token::RParen,
        "{" => Token::LBrace,
        "}" => Token::RBrace,

        "int_literal" => Token::IntLiteral(<i64>),
        "float_literal" => Token::FloatLiteral(<f64>),
        "bool_literal" => Token::BoolLiteral(<bool>),
        "string_literal" => Token::StringLiteral(<String>),

        "ident" => Token::Ident(<String>),
    }
}

Ident: ast::Ident = {
    <i:"ident"> => ast::Ident(i.to_string()),
};

ResIdent: ast::ResIdent = {
    <ident:Ident> => ast::ResIdent::new(ident),
};

// top-level grammar rule
pub Program: ast::Program = {
    Item* => ast::Program { items: <> }
};

Item: ast::Item = {
    <a:DeclAssignment> ";" => ast::Item::GlobalVar(a),
    <f:FunctionDefinition> => ast::Item::Func(f),
};

FunctionDefinition: ast::FuncDef = {
    <return_type:Type> <ident:Ident> "(" <p:ParameterList?> ")" "{" <statements:StatementList> "}" =>
        ast::FuncDef {
             return_type,
             ident,
             params: p.unwrap_or(vec![]),
             statements
        },
};

ParameterList: Vec<ast::FuncParam> = {
    <data_type:Type> <ident:Ident> <end:("," <Type> <Ident>)*> => {
        let mut last_params = end;
        last_params.insert(0, (data_type, ident));
        last_params.into_iter().map(|(d, i)|
            ast::FuncParam { data_type: d, ident: i } ).collect::<Vec<ast::FuncParam>>()
    }
};

FunctionCall: ast::FuncCall = {
    <res_ident:ResIdent> "(" <args:(<Assignment> <("," <Assignment>)*>)?> ")" =>
        ast::FuncCall {
            res_ident,
            args: args.map(|(a, mut v)| {
                        v.insert(0, a);
                        v
                    })
                        .unwrap_or(vec![]),
        }
}

StatementList: Vec<ast::Stmt> = {
    Statement* => <>
};

Block: ast::Block = {
    "{" <statements:StatementList> "}" => ast::Block { statements }
};

Statement: ast::Stmt = {
    <i:IfStatement> => ast::Stmt::If(i),
    <n:NoIfStatements> => n
};

NoIfStatements: ast::Stmt = {
    <f:ForStatement> => ast::Stmt::For(f),
    <d:DoWhileStatement> ";" => ast::Stmt::DoWhile(d),
    <w:WhileStatement> => ast::Stmt::While(w),
    <r:ReturnStatement> ";" => ast::Stmt::Return(r),
    <p:Print> ";" => ast::Stmt::Print(p),
    <d:DeclAssignment> ";" => ast::Stmt::VarDef(d),
    <a:StatAssignment> ";" => ast::Stmt::Assign(a),
    <f:FunctionCall> ";" => ast::Stmt::Call(f),
    <b:Block> => ast::Stmt::Block(b),
    ";" => ast::Stmt::Empty
};

IfStatement: ast::IfStmt = {
    <i:MatchedIf> => i,
    <i:UnmatchedIf> => i
};

MatchedIf: ast::IfStmt = {
    "if" "(" <cond:Assignment> ")" <tr:MatchedIf> "else" <el:MatchedIf> =>
        ast::IfStmt {
            cond,
            if_true: Box::new(ast::Stmt::If(tr)),
            if_false: Some(Box::new(ast::Stmt::If(el)))
        },
    "if" "(" <cond:Assignment> ")" <tr:NoIfStatements> "else" <el:MatchedIf> =>
        ast::IfStmt {
            cond,
            if_true: Box::new(tr),
            if_false: Some(Box::new(ast::Stmt::If(el)))
        },
    "if" "(" <cond:Assignment> ")" <tr:NoIfStatements> "else" <el:NoIfStatements> =>
        ast::IfStmt {
            cond,
            if_true: Box::new(tr),
            if_false: Some(Box::new(el))
        }
};

UnmatchedIf: ast::IfStmt = {
    "if" "(" <cond:Assignment> ")" <tr:Statement> =>
        ast::IfStmt {
            cond,
            if_true: Box::new(tr),
            if_false: None
        },
    "if" "(" <cond:Assignment> ")" <tr:MatchedIf> "else" <el:UnmatchedIf> =>
        ast::IfStmt {
            cond,
            if_true: Box::new(ast::Stmt::If(tr)),
            if_false: Some(Box::new(ast::Stmt::If(el)))
        }
};

ForStatement: ast::ForStmt = {
/*
    "for" "(" <init:DeclAssignment> ";" <cond:Expr> ";" <update:StatAssignment> ")" <body:Statement> =>
        ast::ForStmt {
            init: ast::ForInit::VarDef(init),
            cond,
            update,
            body: Box::new(body)
        },
    "for" "(" <init:StatAssignment> ";" <cond:Expr> ";" <update:StatAssignment> ")" <body:Statement> =>
        ast::ForStmt {
            init: ast::ForInit::Assign(init),
            cond,
            update,
            body: Box::new(body)
        }
*/
};

DoWhileStatement: ast::WhileStmt = {
    "do" <body:Statement> "while" "(" <cond:Assignment> ")" =>
        ast::WhileStmt {
            cond,
            body: Box::new(body)
        }
};

WhileStatement: ast::WhileStmt = {
/*
    "while" "(" <cond:Assignment> ")" <body:Statement> =>
        ast::WhileStmt {
            cond,
            body: Box::new(body)
        }
*/
};

ReturnStatement: Option<ast::Expr> = {
    "return" <expr:Expr?> => expr
};

Print: ast::PrintStmt = {
    "print" "(" <expr:Expr> ")" => ast::PrintStmt::Expr(expr),
    "print" "(" <string:"string_literal"> ")" => ast::PrintStmt::String(string.to_string()),
};

DeclAssignment: ast::VarDef = {
    <data_type:Type> <res_ident:ResIdent> <init:("=" <Assignment>)?> =>
        ast::VarDef {
            data_type,
            res_ident,
            init
        }
};

Type: ast::DataType = {
    "bool" => ast::DataType::Bool,
    "float" => ast::DataType::Float,
    "int" => ast::DataType::Int,
    "void" => ast::DataType::Void,
};

StatAssignment: ast::Assign = {
    <lhs:ResIdent> "=" <right:Assignment> => ast::Assign { lhs, rhs: Box::new(right) }
};

Assignment: ast::Expr = {
    <a:StatAssignment> => ast::Expr::Assign(a),
    <e:Expr> => e
};

Expr: ast::Expr = {
    <s:SimpExpr> => s,
    <b:BinOpExpr> => ast::Expr::BinaryOp(b),
};

BinOpExpr: ast::BinOpExpr = {
    <lhs:BoxedSimpExpr> "==" <rhs:BoxedSimpExpr> => ast::BinOpExpr { op: ast::BinOp::Eq, lhs, rhs },
    <lhs:BoxedSimpExpr> "!=" <rhs:BoxedSimpExpr> => ast::BinOpExpr { op: ast::BinOp::Neq, lhs, rhs },
    <lhs:BoxedSimpExpr> "<=" <rhs:BoxedSimpExpr> => ast::BinOpExpr { op: ast::BinOp::Leq, lhs, rhs },
    <lhs:BoxedSimpExpr> ">=" <rhs:BoxedSimpExpr> => ast::BinOpExpr { op: ast::BinOp::Geq, lhs, rhs },
    <lhs:BoxedSimpExpr> "<" <rhs:BoxedSimpExpr> => ast::BinOpExpr { op: ast::BinOp::Lt, lhs, rhs },
    <lhs:BoxedSimpExpr> ">" <rhs:BoxedSimpExpr> => ast::BinOpExpr { op: ast::BinOp::Gt, lhs, rhs },
};

BoxedSimpExpr: Box<ast::Expr> = {
    <s:SimpExpr> => Box::new(s)
};

SimpExpr: ast::Expr = {
    <t:Term> => t,
    <lhs:BoxedTerm> "+" <rhs:BoxedTerm> => ast::Expr::BinaryOp(ast::BinOpExpr { op: ast::BinOp::Add, lhs, rhs }),
    <lhs:BoxedTerm> "-" <rhs:BoxedTerm> => ast::Expr::BinaryOp(ast::BinOpExpr { op: ast::BinOp::Sub, lhs, rhs }),
    <lhs:BoxedTerm> "||" <rhs:BoxedTerm> => ast::Expr::BinaryOp(ast::BinOpExpr { op: ast::BinOp::LogOr, lhs, rhs }),
};

BoxedTerm: Box<ast::Expr> = {
    <t:Term> => Box::new(t)
};

Term: ast::Expr = {
    <f:Factor> => f,
    <lhs:BoxedFactor> "*" <rhs:BoxedFactor> =>
         ast::Expr::BinaryOp(ast::BinOpExpr { op: ast::BinOp::Mul, lhs, rhs }),
    <lhs:BoxedFactor> "/" <rhs:BoxedFactor> =>
        ast::Expr::BinaryOp(ast::BinOpExpr { op: ast::BinOp::Div, lhs, rhs }),
    <lhs:BoxedFactor> "&&" <rhs:BoxedFactor> =>
        ast::Expr::BinaryOp(ast::BinOpExpr { op: ast::BinOp::LogAnd, lhs, rhs }),
};

BoxedFactor: Box<ast::Expr> = {
    <f:Factor> => Box::new(f)
};

Factor: ast::Expr = {
    "-" <f:Factor> => ast::Expr::UnaryMinus(Box::new(f)),
    <i:"int_literal"> => ast::Expr::Literal(ast::Literal::Int(i)),
    <f:"float_literal"> => ast::Expr::Literal(ast::Literal::Float(f)),
    <b:"bool_literal"> => ast::Expr::Literal(ast::Literal::Bool(b)),
    <c:FunctionCall> => ast::Expr::Call(c),
    "(" <a:Assignment> ")" => a
};
